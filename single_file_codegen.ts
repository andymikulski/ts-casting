import fs from "fs";
import path from "path";
import { InterfaceDeclaration, Project, PropertySignature, Type, ts } from "ts-morph";

const project = new Project();
project.addSourceFilesFromTsConfig(
  path.resolve(__dirname, "./tsconfig.json")
);


let generatedCode = `// This is an autogenerated file, DO NOT EDIT.
// This file was generated by running \`npm run gen:components\`.

const Cast = {`;
let imports = new Set<string>();

project.getSourceFiles().forEach(sourceFile => {
  let hasOutput = false;

  console.log('generating ' + sourceFile.getBaseName());

  const interfaces = sourceFile.getInterfaces();


  const nullRegex = /\s*\|\s*null\s*|\s*null\s*\|\s*/ig;
  const checkNullable = (type: Type<ts.Type>, prop: PropertySignature) => type.isNull() || type.isNullable() || nullRegex.test(prop.getTypeNodeOrThrow().getText());


  const processInterface = (interfaceDeclaration: InterfaceDeclaration, propertiesCheckCode: string[] = []) => {
    hasOutput = true;
    const interfaceName = interfaceDeclaration.getName();
    imports.add(interfaceName);

    // For interfaces with extensions, we will simply confirm that we can cast to the ancestors
    interfaceDeclaration.getBaseDeclarations().forEach((i) => {
      propertiesCheckCode.push(`Cast.to${i.getName()!.slice(1)}(obj) !== null`);
    });

    interfaceDeclaration.getMethods().forEach((meth) => {
      const propName = meth.getName();
      propertiesCheckCode.push(`typeof(obj.${propName}) === "function"`);
    });

    interfaceDeclaration.getProperties().forEach((prop) => {
      const type = prop.getType();
      if (prop.hasQuestionToken()) {
        return;
      }

      const nullable = checkNullable(type, prop);

      const propName = prop.getName();
      if (nullable) {
        propertiesCheckCode.push(`(typeof(obj.${propName}) === "${type.getText()}" || obj.${propName} === null)`);
      } else {
        propertiesCheckCode.push(`typeof(obj.${propName}) === "${type.getText()}"`);
      }
    });

    console.log(`Generated ${interfaceName} methods...`);

    return propertiesCheckCode;
  };

  interfaces.forEach(int => {
    const interfaceName = int.getName();
    var compiledPropChecks = processInterface(int);

    generatedCode += `
  to${interfaceName.slice(1)}: function (obj: any): ${interfaceName} | null {
    return (${compiledPropChecks.join(" && ")}) ? obj : null;
  },`;

  });


});


generatedCode += `\n};\n`;
generatedCode = `import type { ${Array.from(imports.values()).sort().join(", ")} } from './cast.gen.ts';\n\n${generatedCode}\n\nexport default Cast;`;
fs.writeFileSync(path.resolve(__dirname, `./src/cast.gen.ts`), generatedCode);