import fs from "fs";
import path from "path";
import { InterfaceDeclaration, Project, SourceFile } from "ts-morph";
import { checkNullable } from "./checkNullable";

const project = new Project();
const TSCONFIG_PATH = path.resolve(__dirname, "./tsconfig.json");
const GEN_FILE_EXT = '.gen.ts';

const PREFER_REUSE_CAST_FUNCTIONS = false;


function getHeader(file: SourceFile) {
  return `// This is an autogenerated file, DO NOT EDIT.
// This file was generated from \`${file.getBaseName()}\` by running \`npm run gen:components\`.
`;
}

// Load the source files listed in the tsconfig
project.addSourceFilesFromTsConfig(TSCONFIG_PATH);

// Process each file, i.e. generate a `[filename].gen.ts` if necessary
project.getSourceFiles().forEach(processFile);

function processFile(sourceFile: SourceFile) {
  // If this function is called on a previously-generated file, ignore it
  if (sourceFile.getBaseName().endsWith(GEN_FILE_EXT)) {
    return;
  }


  const outputFilePath = path.resolve(sourceFile.getDirectoryPath(), `./${sourceFile.getBaseNameWithoutExtension()}${GEN_FILE_EXT}`);

  // If this file exists already, just straight up remove it.
  // It may be outdated and no longer necessary, so this will prune the file.
  // If it IS needed, then it'll simply be regenerated.
  if (fs.existsSync(outputFilePath)) {
    fs.unlinkSync(outputFilePath);
  }



  const interfaces = sourceFile.getInterfaces();

  // If there are no interfaces in this file at all, then we don't need to look at it further
  if (interfaces.length == 0) {
    // console.log('Nothing to process in ' + sourceFile.getBaseName());
    return;
  }
  console.log('Processing ' + sourceFile.getBaseName() + '...');


  let imports = new Map<SourceFile, string[]>();
  let generatedCode = '';

  // for each interface found in this source file...
  interfaces.forEach(int => {
    const interfaceName = int.getName();
    var compiledPropChecks = processInterface(int, imports);

    generatedCode += `
export function Cast${interfaceName.slice(1)}(obj: any): ${interfaceName} | null {
  return (${compiledPropChecks.join(" && ")}) ? obj : null;
}
`;
  });

  // generatedCode = `import type { ${Array.from(imports.values()).sort().join(", ")} } from './${sourceFile.getBaseNameWithoutExtension()}';\n\n${generatedCode}`;

  let importString = '';
  const items = imports.entries();

  let value: [SourceFile, string[]];
  while (value = items.next()?.value) {
    const [file, members] = value;
    importString += `import type { ${members.join(', ')} } from '${file.getRelativePathAsModuleSpecifierTo(sourceFile.getDirectoryPath())}/${file.getBaseNameWithoutExtension()}';\n`;
  }

  generatedCode = getHeader(sourceFile) + importString + generatedCode

  fs.writeFileSync(outputFilePath, generatedCode);
}


function processInterface(interfaceDeclaration: InterfaceDeclaration, importsRef: Map<SourceFile, string[]>, isInherited: boolean = false) {
  const propertiesCheckCode: string[] = [];
  const interfaceName = interfaceDeclaration.getName();
  if (!isInherited) {
    const file = interfaceDeclaration.getSourceFile()
    const list = (importsRef.get(file) ?? []);
    list.push(interfaceName);
    importsRef.set(file, list);
  }

  // For interfaces with extensions, we will simply confirm that we can cast to the ancestors

  // IF TRYING TO REUSE EXISTING CAST FUNCTIONS...
  if (PREFER_REUSE_CAST_FUNCTIONS) {
    interfaceDeclaration.getBaseDeclarations().forEach((i) => {
      propertiesCheckCode.push(`Cast${i.getName()!.slice(1)}(obj) !== null`);
    });
  } else {
    interfaceDeclaration.getBaseDeclarations().filter(x => x instanceof InterfaceDeclaration).forEach((i) => {
      propertiesCheckCode.push.apply(
        propertiesCheckCode, processInterface(<InterfaceDeclaration>i, importsRef, true)
      )
    });
  }

  // Ensure all methods exist. (Unfortunately we can't check if the return types are compatible!)
  interfaceDeclaration.getMethods().forEach((meth) => {
    const propName = meth.getName();
    propertiesCheckCode.push(`typeof(obj.${propName}) === "function"`);
  });

  // Check the fields for the given interface, confirming the types are correct
  interfaceDeclaration.getProperties().forEach((prop) => {
    const type = prop.getType();
    if (prop.hasQuestionToken()) {
      return;
    }

    const nullable = checkNullable(type, prop);

    const propName = prop.getName();
    if (nullable) {
      propertiesCheckCode.push(`(typeof(obj.${propName}) === "${type.getText()}" || obj.${propName} === null)`);
    } else {
      propertiesCheckCode.push(`typeof(obj.${propName}) === "${type.getText()}"`);
    }
  });

  if (!isInherited) {
    console.log(`\tGenerated ${interfaceName} methods...`);
  }

  return propertiesCheckCode;
};